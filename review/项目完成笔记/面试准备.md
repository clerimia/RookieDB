# RookieDB 项目面试准备指南

## 核心技术栈概览

### 1. 查询优化层
#### 基于成本的动态规划优化
**核心知识点**：
- System R 动态规划算法原理
- 查询计划空间枚举
- 成本估算模型（I/O 成本、CPU 成本、内存成本）
- 谓词下推（Predicate Pushdown）
- 索引扫描选择（Index Scan Selection）

**可能的问题**：
```
Q: 你实现的查询优化器是怎么工作的？
A: 我实现了基于 System R 的动态规划算法来优化多表连接查询：
1. 使用动态规划枚举所有可能的连接顺序，计算每种顺序的执行成本
2. 建立成本模型，考虑 I/O 成本、CPU 成本和内存成本
3. 实现谓词下推优化，将选择条件下推到扫描操作符
4. 支持索引扫描选择，根据查询条件自动选择最优访问路径
5. 对复杂查询，相比暴力连接性能提升 5-10 倍

Q: 动态规划在查询优化中有什么优势？
A: 相比其他优化方法：
1. 能保证找到全局最优解
2. 时间复杂度可控，适合中等复杂度查询
3. 实现相对简单，易于理解和维护
4. 可以自然集成启发式规则

Q: 你是怎么估算查询执行成本的？
A: 我的成本估算基于：
1. 统计信息：表的行数、页数、索引选择性
2. I/O 成本：页面读取次数、磁盘寻道时间
3. CPU 成本：记录比较、函数计算开销
4. 内存成本：缓冲区占用、临时空间使用
```

#### 执行引擎层
**核心知识点**：
- 迭代器模式（Iterator Pattern）
- 块嵌套循环连接（Block Nested Loop Join）
- Grace 哈希连接（Grace Hash Join）
- 排序合并连接（Sort Merge Join）
- 外部排序算法
- 外部哈希算法
- 流水线执行（Pipeline Execution）

**可能的问题**：
```
Q: 你实现了哪些连接算法？它们的特点是什么？
A: 我实现了三种主要连接算法：
1. 块嵌套循环连接（BNLJ）：
   - 适用于小表连接大表
   - 内存使用效率高，实现简单
2. Grace 哈希连接（GHJ）：
   - 适用于大规模数据的等值连接
   - 分两个阶段：分区和连接
3. 排序合并连接（SortMergeJoin）：
   - 适用于已排序或可排序的数据
   - 保证输出有序，支持范围查询

Q: 外部排序是怎么实现的？
A: 我的外部排序实现包括：
1. 分阶段排序：将大数据分块，在内存中排序后写回磁盘
2. 多路归并：合并多个已排序的块生成最终有序输出
3. 内存管理：控制内存使用，支持超出内存容量的数据排序
4. I/O 优化：减少磁盘读写次数

Q: 迭代器模式有什么优势？
A: 迭代器模式的优势：
1. 惰性求值：只在需要时计算数据
2. 内存高效：不需要一次性加载所有数据
3. 流水线执行：支持操作符之间的数据流管道
4. 组合灵活：可以轻松组合不同操作符
```

### 2. 存储引擎层
#### B+ 树索引
**核心知识点**：
- B+ 树 vs B 树的区别和优势
- 节点分裂和合并算法
- 叶节点和内部节点的区别
- 并发控制（latch-coupling）
- 范围查询和点查询
- 批量加载优化

**可能的问题**：
```
Q: 为什么数据库选择 B+ 树而不是 B 树？
A: B+ 树相比 B 树有这些优势：
1. 所有数据都在叶节点，支持高效的范围查询
2. 叶节点之间有指针，支持顺序访问
3. 内部节点只存键，不存数据，提高扇出度
4. 更好的磁盘局部性，减少 I/O 次数
5. 适合数据库的块存储结构

Q: B+ 树插入时怎么处理节点分裂？
A: 我的实现包括：
1. 从叶节点向上分裂，保持平衡
2. 中间键提升到父节点
3. 分裂后更新父节点指针
4. 并发安全：使用 latch-coupling 技术
5. 容错处理：处理各种边界情况

Q: 你是怎么保证 B+ 树并发安全的？
A: 通过 latch-coupling 技术：
1. 从叶节点开始向上依次获取锁
2. 确保分裂过程中不会有其他线程访问
3. 使用写前日志记录所有修改
4. 释放锁时按相反顺序进行
```

#### 缓冲池管理
**核心知识点**：
- 缓冲区置换策略（LRU, Clock）
- 写回缓存（Write-back Cache）
- 脏页跟踪（Dirty Page Tracking）
- 强制写入机制（Force Write）
- 缓冲区命中率优化

**可能的问题**：
```
Q: LRU 和 Clock 算法的区别是什么？
A: 主要区别：
1. LRU：基于时间顺序，精确但实现复杂
2. Clock：基于引用位，近似但实现简单
3. LRU 适合读密集型工作负载
4. Clock 适合写密集型工作负载
5. Clock 算法硬件友好，支持 O(1) 时间

Q: 写回缓存有什么优势？
A: 写回缓存的优势：
1. 减少 I/O 操作：多个修改在内存中积累后一次写入
2. 提高吞吐量：批量处理磁盘写入
3. 延迟写入：可以选择合适的写入时机
4. 故障恢复：通过日志确保数据不丢失
```

### 3. 事务管理层
#### 并发控制
**核心知识点**：
- 严格两阶段封锁协议（Strict 2PL）
- 锁类型（S, X, IS, IX, SIX）
- 锁兼容性矩阵
- 多粒度锁（数据库、表、页面）
- 死锁检测和预防
- 锁升级机制

**可能的问题**：
```
Q: 什么是严格两阶段封锁协议？
A: Strict 2PL 的要点：
1. 第一阶段：获取所有需要的锁才能继续执行
2. 第二阶段：在事务结束前不能释放任何锁
3. 严格性：所有锁都等到事务提交或回滚时才释放
4. 保证可串行化：避免级联回滚和幻读

Q: 多粒度锁有什么优势？
A: 多粒度锁的优势：
1. 提高并发度：细粒度锁减少冲突
2. 意向锁机制：提前表明加锁意图
3. 锁升级：从意向锁升级到实际锁
4. 层次结构：数据库→表→页面的锁层次
5. 减少死锁：更精确的锁范围

Q: 锁的兼容性是怎么判断的？
A: 锁兼容性基于矩阵：
1. S 锁与 S 锁兼容，与 X 锁冲突
2. IS 锁与所有锁兼容（除了 X）
3. IX 锁与 S、IS 兼容，与 X、IX 冲突
4. SIX 锁只与 IS 锁兼容
```

#### 恢复机制
**核心知识点**：
- ARIES 恢复算法三个阶段
- Write-Ahead Logging（WAL）
- 检查点机制（Checkpoint）
- 补偿日志记录（CLR）
- 事务表和脏页表
- 模糊检查点

**可能的问题**：
```
Q: ARIES 恢复的三个阶段分别做什么？
A: ARIES 三阶段：
1. 分析阶段：从检查点开始扫描日志，重建事务表和脏页表
2. 重做阶段：从检查点开始重做所有已提交事务的操作
3. 撤销阶段：对未完成的事务进行回滚，生成补偿日志

Q: 什么是 Write-Ahead Logging？
A: WAL 的核心原则：
1. 日志记录必须在对数据页面修改前写入磁盘
2. 确保故障恢复时可以重建数据库状态
3. 支持事务的原子性和持久性
4. 是现代数据库系统的标准技术

Q: 检查点有什么作用？
A: 检查点的作用：
1. 减少恢复时间：不需要扫描全部日志
2. 定期保存数据库状态：减少日志文件大小
3. 支持快速恢复：从检查点开始恢复
4. 模糊检查点：不影响系统运行的情况下进行
```

## 面试准备策略

### 1. 后端工程师重点准备
**核心技能匹配**：
- **系统设计能力**：分布式系统、微服务架构、负载均衡
- **并发编程经验**：多线程、线程安全、分布式锁
- **数据一致性**：ACID 特性、事务管理、数据同步
- **性能优化**：缓存策略、数据库优化、系统调优
- **工程实践**：设计模式、代码重构、测试驱动开发

**重点准备领域**：
- **查询优化**：动态规划、成本估算、谓词下推
- **执行引擎**：连接算法、外部排序、迭代器模式
- **存储引擎**：B+ 树、缓冲管理、页面置换
- **事务管理**：并发控制、锁机制、ARIES 恢复
- **系统设计**：分布式架构、一致性协议、容错机制

### 2. 运维开发重点准备
**核心技能匹配**：
- **系统监控**：日志分析、性能监控、告警机制
- **自动化运维**：CI/CD 流程、容器化部署、配置管理
- **故障排查**：问题定位、根因分析、恢复策略
- **数据处理**：大数据处理、ETL 流程、数据管道
- **高可用性**：负载均衡、故障转移、灾备方案

**重点准备领域**：
- **监控和告警**：系统监控工具、日志分析、性能指标
- **自动化部署**：Docker 容器、Kubernetes、脚本化运维
- **故障处理**：应急响应、问题诊断、恢复流程
- **性能调优**：系统瓶颈分析、资源优化、容量规划

**准备方法**：
1. **概念理解**：能够用简单语言解释复杂概念
2. **实现细节**：熟悉关键算法的实现细节
3. **性能分析**：能够分析不同算法的优缺点
4. **场景应用**：能够在具体场景中选择合适的技术

### 2. 项目介绍准备
**STAR 原则应用**：
```
S (Situation): 基于 UC Berkeley CS186 框架实现数据库核心模块

T (Task): 负责查询优化和执行引擎相关模块的实现

A (Action): 
- 实现基于成本的动态规划查询优化器
- 完成多种连接算子和外部算法
- 优化 B+ 树索引和缓冲池管理
- 参与并发控制和恢复机制的集成测试

R (Result): 
- 深入理解数据库系统内部机制
- 掌握复杂系统的工程实现方法
- 具备数据库内核开发的技术能力
```

**项目演示要点**：
1. **环境准备**：确保项目可以正常编译和运行
2. **功能展示**：准备典型的查询场景演示
3. **性能对比**：展示优化前后的性能差异
4. **代码讲解**：能够现场解释关键实现代码

### 3. 手撕代码准备
**高频算法题**：
- 动态规划：查询优化相关
- 树操作：B+ 树的插入、删除、查找
- 排序算法：快速排序、归并排序、外部排序
- 哈希算法：哈希表、布隆过滤器
- 并发控制：死锁检测、锁机制实现

**实现要点**：
1. **边界条件**：特别注意数组越界、空指针等
2. **时间复杂度**：能够分析算法的时间和空间复杂度
3. **代码风格**：清晰的变量命名、合理的函数分解
4. **测试用例**：考虑正常、边界、异常情况

### 4. 系统设计问题
**可能的问题**：
```
Q: 如何将这个单机数据库扩展为分布式数据库？
A: 扩展思路：
1. 分片策略：基于范围或哈希的数据分片
2. 一致性协议：实现分布式事务和一致性保证
3. 故障处理：处理节点故障和网络分区
4. 负载均衡：查询路由和负载分配
5. 元数据管理：分布式环境下的表和索引管理

Q: 如何优化这个数据库的性能？
A: 优化方向：
1. 查询优化：更好的统计信息、成本模型
2. 索引优化：复合索引、覆盖索引
3. 缓冲优化：更大的缓冲池、更好的置换策略
4. 并发优化：减少锁冲突、提高并发度
5. I/O 优化：顺序读写、批量操作

Q: 如何添加 MVCC 支持？
A: MVCC 实现思路：
1. 版本存储：为每条记录存储多个版本
2. 时间戳排序：使用时间戳确定版本可见性
3. 垃圾回收：清理不再需要的旧版本
4. 快照隔离：为事务提供一致的数据快照
5. 读已提交：避免不可重复读问题
```

## 面试当天准备

### 1. 材料准备
- **纸质简历**：打印 2-3 份
- **项目演示**：准备好可运行的 demo 环境
- **代码准备**：关键代码段的备份和注释
- **笔记整理**：技术要点的思维导图

### 2. 心态调整
- **自信表达**：清楚了解自己的技术贡献
- **诚实沟通**：诚实说明基于框架的实现
- **积极态度**：展现学习能力和解决问题的热情
- **主动提问**：准备有深度的技术问题

### 3. 后续跟进
- **感谢邮件**：面试后 24 小时内发送感谢信
- **补充材料**：根据面试问题补充技术细节
- **持续学习**：针对面试中发现的知识盲区进行学习

记住：你的项目技术深度足够应对大部分数据库相关面试，关键是能够清晰、深入地表达你的理解和实现！
