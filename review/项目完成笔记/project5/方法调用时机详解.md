# Project5 方法调用时机详解

## 数据库生命周期

### 启动阶段
```
Database.start()
├── RecoveryManager.setManagers()        // 设置管理器
├── RecoveryManager.restart()              // 执行恢复
└── RecoveryManager.initialize()           // 首次初始化(仅新数据库)
```

### 正常运行阶段
```
事务生命周期
├── RecoveryManager.startTransaction()     // 事务开始
├── 各种日志方法                        // 操作记录
├── RecoveryManager.commit()              // 事务提交
├── RecoveryManager.abort()               // 事务中止
├── RecoveryManager.end()                 // 事务结束
└── RecoveryManager.checkpoint()         // 定期检查点
```

### 关闭阶段
```
Database.close()
└── RecoveryManager.close()              // 清理并最后检查点
```

## 事务生命周期方法调用

### 1. startTransaction(long transNum)
**调用时机**：
- Transaction.beginTransaction()时
- 用户执行BEGIN TRANSACTION时
- 系统自动创建内部事务时

**调用链**：
```
Transaction.beginTransaction()
└── RecoveryManager.startTransaction(this)
    └── transactionTable.put(transNum, new TransactionTableEntry(transaction))
```

**关键操作**：
- 创建TransactionTableEntry
- 初始化lastLSN = 0
- 初始化空的savepoints映射

### 2. commit(long transNum)
**调用时机**：
- Transaction.commit()时
- 用户执行COMMIT时
- 自动提交模式下语句执行结束时

**调用链**：
```
Transaction.commit()
└── RecoveryManager.commit(transNum)
    ├── 创建CommitTransactionLogRecord
    ├── logManager.appendToLog(record)
    ├── logManager.flushToLSN(commitLSN)  // WAL保证
    └── entry.transaction.setStatus(COMMITTING)
```

**关键操作**：
- 写入COMMIT记录
- 强制刷新日志到磁盘
- 更新事务状态为COMMITTING
- 更新lastLSN

### 3. abort(long transNum)
**调用时机**：
- Transaction.abort()时
- 用户执行ROLLBACK时
- 死锁检测到需要中止时
- 系统错误需要回滚时

**调用链**：
```
Transaction.abort()
└── RecoveryManager.abort(transNum)
    ├── 创建AbortTransactionLogRecord
    ├── logManager.appendToLog(record)
    └── entry.transaction.setStatus(RECOVERY_ABORTING)
```

**关键操作**：
- 写入ABORT记录
- 更新事务状态为RECOVERY_ABORTING
- 更新lastLSN
- 注意：不执行实际回滚

### 4. end(long transNum)
**调用时机**：
- Transaction.cleanup()时
- 提交事务的清理阶段
- 中止事务的回滚完成后

**调用链**：
```
Transaction.cleanup()
└── RecoveryManager.end(transNum)
    ├── 如果状态是RECOVERY_ABORTING → rollbackToLSN(transNum, 0)
    ├── 创建EndTransactionLogRecord
    ├── logManager.appendToLog(record)
    ├── entry.transaction.setStatus(COMPLETE)
    ├── transactionTable.remove(transNum)
    └── entry.transaction.cleanup()
```

**关键操作**：
- 中止时执行完整回滚
- 写入END记录
- 从事务表中移除
- 调用Transaction.cleanup()

## 页面操作方法调用

### 1. logPageWrite() - 核心页面修改
**调用时机**：
```
BufferManager.pin() + 修改页面内容
└── RecoveryManager.logPageWrite()
```

**具体触发点**：
- Page.setBytes() - 设置页面字节数据
- Page.read/write - 数据读写操作
- 索引节点分裂/合并
- 表数据插入/更新/删除

**调用链**：
```
页面修改操作
└── RecoveryManager.logPageWrite(transNum, pageNum, offset, before, after)
    ├── 创建UpdatePageLogRecord
    ├── logManager.appendToLog(record)
    ├── entry.lastLSN = updateLSN
    └── dirtyPage(pageNum, updateLSN)
```

**关键操作**：
- 记录before/after镜像
- 更新事务表的lastLSN
- 更新脏页表（如果需要）

### 2. logAllocPage() / logFreePage()
**调用时机**：
```
DiskSpaceManager.allocPage() / freePage()
└── RecoveryManager.logAllocPage() / logFreePage()
```

**具体触发点**：
- 表扩展分配新页面
- 索引分裂分配新页面
- 删除表/索引释放页面

**关键操作**：
- 立即刷新日志（WAL）
- 更新事务表lastLSN
- 对于freePage，从脏页表移除

### 3. logAllocPart() / logFreePart()
**调用时机**：
```
DiskSpaceManager.allocPart() / freePart()
└── RecoveryManager.logAllocPart() / logFreePart()
```

**具体触发点**：
- 创建新表/索引
- 删除表/索引

## Savepoint方法调用

### 1. savepoint(long transNum, String name)
**调用时机**：
```
Transaction.savepoint(name) / SQL SAVEPOINT name
└── RecoveryManager.savepoint(transNum, name)
```

**使用场景**：
- 复杂事务的分阶段标记
- 可能回滚点的预设
- 嵌套事务模拟

### 2. rollbackToSavepoint(long transNum, String name)
**调用时机**：
```
Transaction.rollbackToSavepoint(name) / SQL ROLLBACK TO name
└── RecoveryManager.rollbackToSavepoint(transNum, name)
    └── rollbackToLSN(transNum, savepointLSN)
```

### 3. releaseSavepoint(long transNum, String name)
**调用时机**：
```
Transaction.releaseSavepoint(name) / SQL RELEASE SAVEPOINT name
└── RecoveryManager.releaseSavepoint(transNum, name)
```

## 缓冲管理交互

### 1. pageFlushHook(long pageLSN)
**调用时机**：
```
BufferManager.evictPage() / Page.flush()
└── RecoveryManager.pageFlushHook(pageLSN)
    └── logManager.flushToLSN(pageLSN)  // WAL保证
```

**关键原则**：
- 确保相关日志先于页面到达磁盘
- 防止恢复时出现不一致

### 2. diskIOHook(long pageNum)
**调用时机**：
```
Page.flush() 完成后
└── RecoveryManager.diskIOHook(pageNum)
    └── dirtyPageTable.remove(pageNum)  // 页面已干净
```

### 3. dirtyPage(long pageNum, long LSN)
**调用时机**：
```
页面被修改时
└── RecoveryManager.dirtyPage(pageNum, LSN)
    └── dirtyPageTable.putIfAbsent(pageNum, LSN)
```

## 恢复相关方法

### 1. restart()
**调用时机**：
```
Database.start() 检测到需要恢复时
└── RecoveryManager.restart()
    ├── restartAnalysis()    // 分析阶段
    ├── restartRedo()       // 重做阶段
    ├── cleanDPT()          // 清理脏页表
    ├── restartUndo()       // 撤销阶段
    └── checkpoint()        // 创建检查点
```

**触发条件**：
- 数据库启动时
- 检测到非正常关闭
- 日志文件存在且需要恢复

### 2. checkpoint()
**调用时机**：
```
定期任务 或 手动触发
└── RecoveryManager.checkpoint()
    ├── 创建BeginCheckpointLogRecord
    ├── 创建EndCheckpointLogRecord(s)
    ├── 刷新日志
    └── 更新MasterLogRecord
```

**触发条件**：
- 定时器触发（如每5分钟）
- 日志大小达到阈值
- 手动执行CHECKPOINT命令
- 数据库正常关闭时

## 日志管理方法

### 1. LogManager.appendToLog()
**调用时机**：
- 所有需要记录操作时
- 每个RecoveryManager日志方法都会调用

**内部流程**：
```
appendToLog(LogRecord record)
├── 检查日志尾页空间
├── 必要时创建新页
├── 序列化记录到页
├── 设置record.LSN
└── 返回LSN
```

### 2. LogManager.fetchLogRecord(long LSN)
**调用时机**：
- 恢复阶段扫描日志
- 回滚时获取历史记录
- 检查点时读取日志

### 3. LogManager.flushToLSN(long LSN)
**调用时机**：
- commit()时（WAL要求）
- 页面刷新前（pageFlushHook）
- 检查点创建时
- 数据库关闭时

## 调用时序图

### 正常事务提交流程
```
用户操作
    ↓
startTransaction() → 创建事务表条目
    ↓
logPageWrite() → 记录每次页面修改
    ↓
commit() → 写COMMIT记录 + 刷新日志
    ↓
end() → 清理事务表 + 写END记录
```

### 事务中止流程
```
用户操作 / 系统错误
    ↓
startTransaction() → 创建事务表条目
    ↓
logPageWrite() → 记录每次页面修改
    ↓
abort() → 写ABORT记录
    ↓
end() → rollbackToLSN() + 清理事务表
```

### 恢复流程
```
数据库启动
    ↓
restart() → 检测需要恢复
    ↓
restartAnalysis() → 重建事务表和脏页表
    ↓
restartRedo() → 重做已提交操作
    ↓
restartUndo() → 撤销未提交操作
    ↓
checkpoint() → 创建恢复后检查点
```

## 关键调用关系总结

### WAL原则保证
1. **日志先写**: 所有页面修改前先写日志
2. **强制刷新**: commit()和页面刷新前强制刷新日志
3. **LSN检查**: 恢复时检查页面LSN确保一致性

### 事务状态管理
1. **状态转换**: RUNNING → COMMITTING/ABORTING → COMPLETE
2. **LSN链**: prevLSN和undoNextLSN的正确维护
3. **清理时机**: 事务结束时正确清理资源

### 并发控制
1. **数据结构同步**: transactionTable和dirtyPage表的线程安全
2. **状态原子性**: 事务状态变更的原子性
3. **日志一致性**: 多线程环境下日志写入的顺序性

理解这些调用时机对正确实现ARIES恢复系统至关重要。
